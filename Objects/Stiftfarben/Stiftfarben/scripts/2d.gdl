dim   icolorData[][5]dict  distance, framecoor! get and set all the colorsfor i = 1 to nColors    ! colors lie in domain of [0..1]    x = request ("RGB_of_pen", i, _red, _green, _blue)    if x then        red   = INT(_red*255)        green = INT(_green*255)        blue  = INT(_blue*255)        gosub "ToHex"        icolorData[i][1] = i        icolorData[i][2] = red        icolorData[i][3] = green        icolorData[i][4] = blue        icolorData[i][5] = totalhex  ! from sub "ToHex"    endifnext i! always rotate the objectif bLockSymbol then    ! --- Oriented View ------------------------------ [    angleViewRot = 0    rrr = REQUEST ("View_Rotangle", "", angleViewRot)    totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360    ! --- Oriented View ------------------------------ ]    add2 -0.4,1.4    rot2 -totalRotate    add2 0.4,-1.4endifdefine style "NumberStyle" fontType, 10/GLOB_SCALE * font_size, 7, festyle "NumberStyle"drawindex 20unID = 1nRow = 0nVertDistance  = 0nHorizDistance = 0! style 2 => with lineif iPenColorSymbStyle = SYMBOL_STYLE_2 then     gosub "style2"else     gosub "style1"endifframecoor.x.left = -0.4framecoor.y.top  = 1.4framecoor.x.rght = nFillsInARow * distance.horzframecoor.y.down = -(nVertDistance * distance.vert)-0.4del nVertDistance + nHorizDistanceif nColors / nFillsInARow = int(nColors / nFillsInARow) then nVertDistance  = nVertDistance  -1hotspot2  framecoor.x.left,         framecoor.y.top,          unID : unID = unID + 1hotspot2  framecoor.x.left,         framecoor.y.down,         unID : unID = unID + 1hotspot2  framecoor.x.rght,         framecoor.y.down,         unID : unID = unID + 1hotspot2  framecoor.x.rght,         framecoor.y.top,          unID : unID = unID + 1hotspot2  framecoor.x.rght/2 -0.2,  framecoor.y.down/2 +0.5,  unID : unID = unID + 1if bFrame then  rect2  framecoor.x.left, framecoor.y.top, framecoor.x.rght, framecoor.y.downdrawindex 10fill     gs_fill_typepoly2_B  5, 2, gs_fill_pen,gs_back_pen,         framecoor.x.left, framecoor.y.top,  1,         framecoor.x.rght, framecoor.y.top,  1,         framecoor.x.rght, framecoor.y.down, 1,         framecoor.x.left, framecoor.y.down, 1,         framecoor.x.left, framecoor.y.top, -1if bLockSymbol then del 1END! -- END -- END -- END -- END -- END -- END -- END -- END -- END -- !! ---------------------------------------------------------------------- !"style1":    distance.horz = 2    distance.vert = 1.2    for i = 1 to nColors        pen icolorData[i][1]        fill fillType        ! .---------.        ! |  /col/  |        ! '----.    |        !  pen !____!        poly2_b   7,      2,  icolorData[i][1], icolorData[i][1],               0.35,      0,  1,  ! we start at bottom mid                  1,      0,  1,  ! going counter-clockwise                  1,      1,  1,                  0,      1,  1,                  0,   0.25,  1,               0.35,   0.25,  1,                 -0,     -0,  700        pen textPen        ! print current pen number        text2  0.02, 0.01, icolorData[i][1]        rect2  0, 0, 1, 1        ! print color values        text2  1.1, 3*0.25,  "R:"        text2  1.4, 3*0.25,  icolorData[i][2]        text2  1.1, 2*0.25,  "G:"        text2  1.4, 2*0.25,  icolorData[i][3]        text2  1.1,   0.25,  "B:"        text2  1.4,   0.25,  icolorData[i][4]        text2  1.1,      0,  icolorData[i][5]  ! hex        add2 distance.horz, 0        nHorizDistance = nHorizDistance + 1        if (i % nFillsInARow = 0) and (i <> nColors) then            del nFillsInARow            nHorizDistance = nHorizDistance - nFillsInARow            add2 0, -distance.vert            nVertDistance = nVertDistance + 1        endif    next iRETURN! ---------------------------------------------------------------------- !"style2":    distance.horz = 4.5    distance.vert = 1.2    for i = 1 to nColors        pen icolorData[i][1]        fill fillType        poly2_b   5,      2,  icolorData[i][1], icolorData[i][1],                0.0,    0.0,  1,                1.0,    0.0,  1,                1.0,    0.8,  1,                0.0,    0.8,  1,                0.0,    0.0, -1        line2   1.3, 0,  3.7, 0        pen   textPen        add2  1.32, 0.11        penNL = STW(`Stift`) * GLOB_SCALE/1000        text2 0, 2*0.25, "• " + str(icolorData[i][1], 1, 0)        text2 0, 0.25,   "R: " + STR(icolorData[i][2], 1, 0) + "   G: " + STR(icolorData[i][3], 1, 0)+ "   B: " + STR(icolorData[i][4], 1, 0)        text2 0, 0,      icolorData[i][5]  ! hex        del 1        add2 distance.horz, 0        nHorizDistance = nHorizDistance + 1        if (i % nFillsInARow = 0) and (i <> nColors) then            del nFillsInARow            nHorizDistance = nHorizDistance - nFillsInARow            add2 0, -distance.vert            nVertDistance= nVertDistance + 1        endif    next iRETURN! ---------------------------------------------------------------------- !"ToHex":    ! handles the code to convert RGB into Hexadecimal    dict __hex    __rgbpart = red    gosub "HexPart"    __hex.red = __part1 + __part2    __rgbpart = green    gosub "HexPart"    __hex.green = __part1 + __part2    __rgbpart = blue    gosub "HexPart"    __hex.blue = __part1 + __part2    totalhex = "#" + __hex.red + __hex.green + __hex.blue    RETURN! ---------------------------------------------------------------------- !"HexPart":    ! divide color by 16; the real part is place one, the fraction times 16 is part two    ! calculation taken from    !  https://www.developintelligence.com/blog/2017/02/rgb-to-hex-understanding-the-major-web-color-codes/    __total = __rgbpart / 16    __part1 = HEX[int(__total)+1]  ! because GDL arrays start at 1    __dec = __total  ! go to sub and calculate the decimal place    gosub "Frac"    __part2 = HEX[(__frac * 16)+1]RETURN! ---------------------------------------------------------------------- !"Frac":    ! gives us the decimal places of any float, even signed    __frac = sgn(__dec) * ( abs(__dec) - int( abs(__dec) ) )RETURN