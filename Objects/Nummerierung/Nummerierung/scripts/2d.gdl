! 2D !fontFx = 0  ! font stylefontFx = bitset(fontFx, 0, fontBold)fontFx = bitset(fontFx, 1, fontItalic)fontFx = bitset(fontFx, 2, fontUnder)define style "text" fontType, fontsize, 5, fontFxstyle "text"uID = 1hotspot2         0, 0, uID, distance, 1+128 : uID=uID+1  ! basehotspot2        -1, 0, uID, distance, 3     : uID=uID+1  ! refhotspot2  distance, 0, uID, distance, 2     : uID=uID+1  ! movif total_n = 1 then    hotspot2 A, 0, uID : uID=uID+1    hotspot2 0, 0, uID : uID=uID+1    add2 A/2, 0endiffor i = n_start to n_end step n_step    if b_readable then  ! always readable        mul2 (1 - 2*SYMB_MIRRORED), 1        rot2 -SYMB_ROTANGLE    endif     hotspot2 0, 0, uID  : uID=uID+1    if GLOB_FEEDBACK_MODE then        ! during hotspot edit insert placeholders        ! text _never_ gets displayed during feedback mode anyway!        line2  -hk/2, -hk,   hk/2,  hk        line2  -hk/2,  hk,   hk/2, -hk    else        ! display        if number_type > 1 then            __letters = ""  ! always init your vars            if number_type = 3 then  !=> alpha                gosub "Alpha"  ! returns __letters            else  !=> roman numerals                gosub "Roman"  ! returns __letters            endif                        text_to_display = __letters            if b_upper then text_to_display = strtoupper(text_to_display)        else  !=> normal plain numbers            text_to_display = str(i, 1, 0)        endif        text_total = prefix + text_to_display + suffix        pen   pen_text        text2 0, 0, text_total        if b_frame or b_fill then  ! let's draw frame and/or backfill            pen   frame_pen            fill  fill_type            ! get the current text sizes            _str_width = ((stw(text_total) + _padding) / 1000 * GLOB_SCALE)/2            _str_height = ((fontsize + _padding) / 1000 * GLOB_SCALE)/2            poly2_b  5, 1*b_frame + 2*b_fill + 4,                     gs_fill_pen, gs_back_pen,                     -_str_width,  _str_height, 1,                     -_str_width, -_str_height, 1,                      _str_width, -_str_height, 1,                      _str_width,  _str_height, 1,                               0,            0, 701        endif            endif    if b_readable then DEL  2    ADD2 x_dist, 0next idel topEND  ! -- END -- END -- END -- END -- END -- END -- END -- END -- END -- !! ---------------------------------------------------------------------- !! ---------------------------------------------------------------------- !"Alpha":    !!! outputs the current input number in an alpha format (1=a, 26=z, 27=aa, etc.)    !!! inputs-> i·number    !!! __letters => ""    __repeat = 0   ! just need to be init    __i = i    while __repeat < 1 do         __k = __i / 26        __l = __i MOD 26        ! catch __l == 0        if __l = 0 then            __l = 26 ! = Z        endif        ! fill in from the left        __letters = _alphabet[__l] + __letters        if int(__k) = 0 or __i = 26 then            ! stop if there is no integer part any longer !            ! --> the number is exhausted            goto "endloop_a"  ! important        else            if __i MOD 26 = 0 then                __i = int(__k) - 1            else                __i = int(__k)            endif        endif    endwhile    "endloop_a":  ! to break out of the otherwise endless 'while true'-loop    RETURN !__letters! ---------------------------------------------------------------------- !"Frac":    !!! gives the fractional part of a float, even when signed    __frac = sgn(__arg) * ( abs(__arg) - int( abs(__arg) ) )RETURN !__frac! ---------------------------------------------------------------------- !"Roman":    !!! outputs an input number as roman numerals    !!! code is based on Don Knuth's LaTeX    !!! https://www.hanshq.net/roman-numerals.html    !!! expects to have an array with the content of ["m", "d", "c", "l", "x", "v", "i"]    __repeat = 0   ! just need to be init    _j = 1         ! current position on the _roman array // GDL array is not zero based!    _v = 1000      ! current value    __letters = "" ! empty at beginning    _n = i         ! init with input value    while __repeat < 1 do  ! beware of what you're doing in this kind of loops!        while _n >= _v do            __letters = __letters + _roman[_j]            _n = _n - _v        endwhile        ! non positive input yields no output        if _n <= 0 goto "endloop_r"  ! important        ! since GDL has no premature return or a `break` keyword we need some "clever" goto        _k = _j + 1  ! update the position        if _k MOD 2 then _div = 5 else _div = 2        _u = _v / _div        if not(_k mod 2) then  !=> if _k is even            _k = _k + 1            if _k MOD 2 then _div = 5 else _div = 2            _u = _u / _div        endif        if _n + _u >= _v then            __letters = __letters + _roman[_k]            _n = _n + _u        else            _j = _j + 1            if _j MOD 2 then _div = 5 else _div = 2            _v = _v / _div        endif            endwhile    "endloop_r":  ! to break out of the otherwise endless 'while true'-loopRETURN !__letters