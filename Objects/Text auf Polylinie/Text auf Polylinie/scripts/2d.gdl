! ******** 2D SCRIPT ******** !! *************************** !! ======= HOTSPOTS ========unID = 1000! ======= FOR SEGMENTS MOVEMENT ========IF movableBaseHotspot THEN 	start = 1 ELSE 	start = 2	HOTSPOT2 0,0ENDIFFOR i = start to points	!x control	HOTSPOT2 0,y[i],		unID,x[i],1+128		:unID=unID+1		!BASE	HOTSPOT2 x[i],y[i],		unID,x[i],2			:unID=unID+1		!MOVE	HOTSPOT2 -1,y[i],		unID,x[i],3 		:unID=unID+1		!REF	!y control	HOTSPOT2 x[i],0,		unID,y[i],1+128		:unID=unID+1		!BASE	HOTSPOT2 x[i],y[i],		unID,y[i],2			:unID=unID+1		!MOVE	HOTSPOT2 x[i],-1,		unID,y[i],3 		:unID=unID+1		!REFNEXT i! === FOR INSERTION OF NEW POINTS ===DIM insertXHotspot[], insertYHotspot[]FOR i=1 TO points-1	insertXHotspot[i] = x[i]+(x[i+1]-x[i])/2	insertYHotspot[i] = y[i]+(y[i+1]-y[i])/2NEXT iFOR i=1 to points-1	!x control	HOTSPOT2 0,insertYHotspot[i],					unID,insertX[i],1+128	:unID=unID+1		!BASE	HOTSPOT2 insertXHotspot[i],insertYHotspot[i],	unID,insertX[i],2		:unID=unID+1		!MOVE	HOTSPOT2 -1,insertYHotspot[i],					unID,insertX[i],3 		:unID=unID+1		!REF	!y control	HOTSPOT2 insertXHotspot[i],0,					unID,insertY[i],1+128	:unID=unID+1		!BASE	HOTSPOT2 insertXHotspot[i],insertYHotspot[i],	unID,insertY[i],2		:unID=unID+1		!MOVE	HOTSPOT2 insertXHotspot[i],-1,					unID,insertY[i],3 		:unID=unID+1		!REFNEXT i! === FOR ADDING POINTS AT END ===!x control	insertEndOffset=0.30	! === CALCULATE END HOTSPOT POSITION: x[OF LAST POINT -1] + x AND y PROJECTIONS ===	IF vardim1(x)>2 THEN		insertXEnd=x[points-1]+(insertEndOffset+hypotenuse2D[points-1])*COS(alpha2D[points-1])		insertYEnd=y[points-1]+(insertEndOffset+hypotenuse2D[points-1])*SIN(alpha2D[points-1])	ELSE		insertXEnd=insertEndOffset		insertYEnd=0	ENDIF!x controlHOTSPOT2 0,insertYEnd,			unID,insertX[points],1+128	:unID=unID+1		!BASEHOTSPOT2 insertXEnd,insertYEnd,	unID,insertX[points],2		:unID=unID+1		!MOVEHOTSPOT2 -1,insertYEnd,			unID,insertX[points],3 		:unID=unID+1		!REF!y controlHOTSPOT2 insertXEnd,0,			unID,insertY[points],1+128	:unID=unID+1		!BASEHOTSPOT2 insertXEnd,insertYEnd,	unID,insertY[points],2		:unID=unID+1		!MOVEHOTSPOT2 insertXEnd,-1,			unID,insertY[points],3 		:unID=unID+1		!REF! === PLUS SIGN ===IF bshowPlusSign THEN	ADD2 insertXEnd, insertYEnd	IF vardim1(x)>2 THEN		ROT2 alpha2D[points-1] * plusSignAligned	ELSE		ROT2 0	ENDIFFOR i=1 TO 4	LINE2 0,0,	insertEndOFfset*0.30,0	ROT2 90NEXT iDEL 6ENDIF! =============================================! =================== LINES ===================PEN 	  gs_cont_penLINE_TYPE linetypeLINE_PROPERTY 2DRAWINDEX 10! Linien:FOR i=1 to segments	LINE2    x[i],y[i],		x[i+1],y[i+1]		HOTLINE2 x[i],y[i],		x[i+1],y[i+1]NEXT iDEFINE STYLE "TOLstyle" fontType, txtsizefactor * 100 / GLOB_SCALE, 5,					gs_text_style_bold + 2 * gs_text_style_italic + 4 * gs_text_style_underlineSET STYLE "TOLstyle"! text:txtWidth = STW(displayText) / 1000 * GLOB_SCALEn = REQUEST ("Height_of_style", "TOLstyle", txtHeight)txtHeight = txtHeight / 1000 * GLOB_SCALEIF bThreshold THEN	nThreshold = txtWidth + 0.2				! bei automatischem Schwellenwert: dieser = Textbreite + wENDIFIF (displayText <> "") AND (txtsizefactor <> 0) THEN 	! sofern es Text zum Darstellen gibt	FOR i=1 to segments		IF hypotenuse2D[i] > nThreshold THEN 			! Segmentlänge muss größer sein als Schwellenwert			gosub "textOnLine"		ENDIF	NEXT iENDIF!**********************************************************************END!**********************************************************************! ===================! === SUBROUTINES ===! ==================="textOnLine":	DRAWINDEX 50	add2 insertXHotspot[i],insertYHotspot[i]		GOSUB "backfill"	rot2 alpha2D[i]		PEN penText		TEXT2 0,0, displayText	del 2return! ---------------------------------------------------------------------- !"backfill":	DRAWINDEX 20	fillX = txtWidth + 0.06	fillY = txtHeight	rot2 alpha2D[i]	add2 -fillX/2, fillY/2		PEN  pen_fillcont		FILL filltxt		LINE_TYPE 1				! Volllinie für Umrandung des Schraffurpolygons		POLY2_B{2} 5, 1+2+4+8+32,					pen_fill, pen_fillback,					0, 0, alpha2D[i],					0, 0, 1,					0, -fillY, 1,					fillX, -fillY, 1,					fillX, 0, 1,					0, 0, -1	del 2RETURN