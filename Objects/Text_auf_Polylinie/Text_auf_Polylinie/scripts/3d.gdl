! ******** 3D SCRIPT ******** !! *************************** !IF NOT(show3D) THEN	ENDENDIF! === HOTSPOTS ===unID = 3000IF NOT(movableBaseHotspot) THEN 	HOTSPOT 0,0,0ENDIFFOR i=2-(1*movableBaseHotspot) to points	HOTSPOT x[i],y[i],0	! z control	IF movableZ THEN		HOTSPOT x[i],y[i],0,		unID,z[i],1+128		:unID=unID+1		!BASE		HOTSPOT x[i],y[i],z[i],		unID,z[i],2			:unID=unID+1		!MOVE		HOTSPOT x[i],y[i],-1,		unID,z[i],3 		:unID=unID+1		!REF	ENDIF	NEXT i! === LINES ===FOR i=1 to segments	IF NOT(linetype3D) THEN 	! wenn nicht Volllinie (=1)		GOSUB "dashed"		ADD x[i+1]-x[i], y[i+1]-y[i], z[i+1]-z[i]	ELSE		LIN_ x[i],y[i],z[i],	x[i+1],y[i+1],z[i+1]	ENDIFNEXT iIF NOT(linetype3D) THEN DEL segmentsFOR i=1 to segments	HOTLINE x[i],y[i],z[i],	x[i+1],y[i+1],z[i+1], unID	:unID=unID+1NEXT i! === TEXT in 3D space ===DEFINE STYLE "3dstyle" fontType, txtsizefactor * 100, 5, 0		! Textgröße muss im 3D anders seinSET STYLE "3dstyle"REQUEST ("RGB_OF_PEN", penText, penText_red, penText_green, penText_blue) DEFINE MATERIAL "matTxt" 2, penText_red, penText_green, penText_blueSET MATERIAL "matTxt"IF (displayText <> "") AND (txtsizefactor <> 0) THEN 	! sofern es Text zum Darstellen gibt	FOR i=1 to segments		IF hypotenuse3D[i] > nThreshold THEN 			! Segmentlänge muss größer sein als Schwellenwert			gosub "textInSpace"		ENDIF	NEXT iENDIF! === EDITING VERTICAL REFERENCES ===IF GLOB_CONTEXT > 20 AND GLOB_CONTEXT < 30 THEN	FOR i=1 TO points		LIN_ x[i],y[i],0,	x[i],y[i],z[i]	NEXT iENDIF!**********************************************************************END!**********************************************************************! ===================! === SUBROUTINES ===! ==================="textInSpace":	__delTrans = 3	add (x[i]+x[i+1])/2, (y[i]+y[i+1])/2, (z[i]+z[i+1])/2 	! Mittelpunkt in 3D	ROTz alpha2D[i]	ROTy -alpha3D[i]	IF bTxtUpright THEN		ROTx 90		__delTrans = __delTrans + 1	ENDIF		PEN penText		TEXT 0.001,0, displayText	del __delTransRETURN! ---------------------------------------------------------------------- !"dashed":	! code idea by James Murray	! https://www.onland.info/archives/2017/06/i_finally_got_around_to_3d_hinge_lines.php	ROTz alpha2D[i]	ROTy -alpha3D[i]	dashStart = 0 ! where the first dash starts	iDashes = 0 ! counter for dashes	flag = 0 ! stopper for while loop	WHILE flag = 0 DO		iDashes = iDashes + 1		! advance to the next dash start		dashStart = dashStart + dashLen + gapLen		! if that's beyond the end, stop		IF dashStart > hypotenuse3D[i] THEN flag = 1	ENDWHILE	! start of final dash	dashStart = dashStart - dashLen - gapLen	! Is the last dash trimmed by the end of the object	IF dashStart + dashLen > hypotenuse3D[i] THEN		bTrimDash = 1		trimLen = hypotenuse3D[i] - dashStart ! special length for last dash	ELSE		bTrimDash = 0 ! object ends with gap, no special dash	ENDIF	! normal dashes, omit last if trimmed	FOR k = 1 TO iDashes - bTrimDash		LIN_ 0, 0, 0, dashLen, 0, 0		ADDx dashLen + gapLen	NEXT k	! special trimmed last dash if needed	IF bTrimDash THEN LIN_ 0, 0, 0, trimLen, 0, 0	DEL iDashes - bTrimDash + 2RETURN